Структури от данни
==================

# Задачи

## Списъци

1. Да се напише функция, която повтаря елементите на даден списък **L** **n**
   на брой пъти.

   *Сигнатура:*

        (repeat n L)

   *Примери:*

        > (repeat 10 '())
        '()

        > (repeat 0 '(1 2 3 4))
        '()

        > (repeat 1 '(1 2 3 4))
        '(1 2 3 4)

        > (repeat 3 '(1 2 3 4))
        '(1 2 3 4 1 2 3 4 1 2 3 4)


2. Да се напише функция, която взима всеки **n**-ти пореден елемент от списък
   **L**.

   *Сигнатура:*

        (each-nth n L)

   *Примери:*

        > (each-nth 0 '(1 2 3 4 5 6 7 8 9 10))
        '()

        > (each-nth 1 '(1 2 3 4 5 6 7 8 9 10))
        '(1 2 3 4 5 6 7 8 9 10)

        > (each-nth 2 '(1 2 3 4 5 6 7 8 9 10))
        '(2 4 6 8 10)

        > (each-nth 3 '(1 2 3 4 5 6 7 8 9 10))
        '(3 6 9)


3. Да се напише функция, която по дадени два списъка **L1** и **L2** връща
   списък, съставен от наредени двойки, като **i**-тата двойка съдържа
   елементите с пореден номер **i** съответно от **L1** и **L2**
   (т.е. т.нар. операция **zip**).

   *Сигнатура:*

        (zip L1 L2)

   *Примери:*

        > (zip '() '())
        '()

        > (zip '(1) '(2))
        '((1 . 2))

        > (zip '(1 3 5 7) '(2 4 6 8))
        '((1 . 2) (3 . 4) (5 . 6) (7 . 8))

        > (zip '(1 3 5 7 9) '(2 4 6 8))
        '((1 . 2) (3 . 4) (5 . 6) (7 . 8))


4. Да се напише функция, която прави същото като *Задача 3.*, но вместо да връща
   наредени двойки с двата елемента, прилага двуаргументната функция **f** върху
   тях (т.е. т.нар. операция **zipWith**).

   *Сигнатура:*

        (zip-with f L1 L2)

   *Примери:*


        > (zip-with + '(1 3 5 7) '(2 4 6 8))
        '(3 7 11 15)

        > (zip-with * '(1 3 5 7 9) '(2 4 6 8))
        '(2 12 30 56)

        > (and (zip < '(1 3 4) '(2 5 7)))
        #t

        > (or (zip > '(1 2 3) (2 1 3)))
        #t


5. Да се напише функция, която връща декартовото произведение на два списъка
   **L1** и **L2**.

   **Дефиниция за декартово произведение:**
   Наредените двойки от вида `(x . y)`, където **x** е елемент на **L1**, а
   **y** е елемент на **L2**.

   *Сигнатура:*

        (cartesian L1 L2)

   *Примери:*

        > (cartesian '() '())
        '()

        > (cartesian '(1) '(2))
        '((1 . 2))

        > (cartesian '(1 2) '(3 4))
        '((1 . 3) (1 . 4) (2 . 3) (2 . 4))

        > (cartesian '(1 3 5) '(2 4 6 8))
        '((1 . 2) (1 . 4) (1 . 6) (1 . 8) (3 . 2) (3 . 4) (3 . 6) (3 . 8) (5 . 2) (5 . 4) (5 . 6) (5 . 8))


6. Да се напише функция, която прави същото като *Задача 5.*, но вместо да връща
   наредени двойки с двата елемента, прилага двуаргументната функция **f** върху
   тях.

   *Сигнатура:*

        (cartesian-apply f L1 L2)

   *Примери:*

        > (cartesian-apply = '() '())
        '()

        > (cartesian-apply < '(1) '(2))
        '(#t)

        > (cartesian-apply * '(1 2) '(3 4))
        '(3 4 6 8)

        > (cartesian-apply + '(1 3 5) '(2 4 6 8))
        '(3 5 7 9 5 7 9 11 7 9 11 13)


7. Да се напише функция, която конкатенира (*append**-ва) рекурсивно елементите
   на списък (т.е. го *сплесква*).

   *Сигнатура:*

        (flatten L)

   *Примери:*

        > (map-rec (lambda (x) (* x 2)) '((1 (2 3 (4 5 6 (7) 8) 9 10 (11 12 (13 (14 15))) 16) 17 18) 19 20))
        '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)


8. Да се напише функция, която проверява дали дадена редица, дефинирана в списък
   **L**, е монотонно растяща.

   *Сигнатура:*

        (increasing? L)

   *Примери:*

        > (increasing? '())
        #t

        > (increasing? '(2))
        #t

        > (increasing? '(2 3 4 5))
        #t

        > (increasing? '(9 8 7 6))
        #f

        > (increasing? '(4 1 7 0))
        #f

        > (increasing? '(12 9 6 2))
        #f

        > (increasing? '(3 4 7 13)
        #t


9. Да се напише функция, която проверява дали дадена редица, дефинирана в списък
   **L**, е монотонно намаляваща.

   *Сигнатура:*

        (decreasing? L)

   *Примери:*

        > (decreasing? '())
        #t

        > (decreasing? '(2))
        #t

        > (decreasing? '(2 3 4 5))
        #f

        > (decreasing? '(9 8 7 6))
        #t

        > (decreasing? '(4 1 7 0))
        #f

        > (decreasing? '(12 9 6 2))
        #t

        > (decreasing? '(3 4 7 13)
        #f


10. Да се напише функция, която проверява дали дадена редица, дефинирана в списък
    **L**, е монотоннa (растяща или намаляваща).

    *Сигнатура:*

        (monotonous? L)

    *Примери:*

        > (monotonous? '())
        #t

        > (monotonous? '(2))
        #t

        > (monotonous? '(2 3 4 5))
        #t

        > (monotonous? '(9 8 7 6))
        #t

        > (monotonous? '(4 1 7 0))
        #f

        > (monotonous? '(12 9 6 2))
        #t

        > (monotonous? '(3 4 7 13)
        #t


11. Да се напише функция, която връща списък от всички локални максимуми в списък
    **L** от числа.

    Дефиниция за локален максимум (учена е по ДИС I :-)):
    Ако съществуват поредни a, b и c -- такива, че а <= b и b >= c, то b е
    локален максимум.

    *Сигнатура:*

        (local-maxima L)

    *Примери:*

        > (local-maxima '(1 2 3 4 5 6 7 8 9 10))
        '()

        > (local-maxima '(1 1 1 1 1 1 1 1))
        '(1 1 1 1 1 1)

        > (local-maxima '(1 0 1 0 1 0 1 0 1))
        '(1 1 1)

        > (local-maxima '(1 2 1 2 3 0 6))
        '(2 3)


12. Да се напише функция, която връща списък от всички локални минимуми в списък
    **L** от числа.

    Дефиниция за локален минимум (учена е по ДИС I :-)):
    Ако съществуват поредни a, b и c -- такива, че а >= b и b <= c, то b е
    локален минимум.

    *Сигнатура:*

        (local-minima L)

    *Примери:*

        > (local-minima '(1 2 3 4 5 6 7 8 9 10))
        '()

        > (local-minima '(1 1 1 1 1 1 1 1))
        '(1 1 1 1 1 1)

        > (local-minima '(1 0 1 0 1 0 1 0 1))
        '(0 0 0 0)

        > (local-minima '(1 2 1 2 3 0 6))
        '(1 0)


13. Да се напише функция, която връща списък от всички локални есктремуми
    (максимуми или минимуми) в списък **L** от числа.

    *Сигнатура:*

        (local-extrema L)

    *Примери:*

        > (local-extrema '(1 2 3 4 5 6 7 8 9 10))
        '()

        > (local-extrema '(1 1 1 1 1 1 1 1))
        '(1 1 1 1 1 1)

        > (local-extrema '(1 0 1 0 1 0 1 0 1))
        '(0 1 0 1 0 1 0)

        > (local-extrema '(1 2 1 2 3 0 6))
        '(2 1 3 0)


14. Да се напише функция, която прилага **map** върху всеки елемент на списък от
    списъци, т.е. прилага функцията **f** върху всеки от елементите на елементите
    на списъка от списъци.

    *Сигнатура:*

        (map-map f L)

    *Примери:*

        > (map-map (lambda (x) 0) '((1) (1 2 3) ()))
        '((0) (0 0 0) ())

        > (map-map (lambda (x) '(1 . 2)) '((1) (1 2 3) ()))
        '(((1 . 2)) ((1 . 2) (1 . 2) (1 . 2)) ())

        > (map-map (lambda (x) '(x)) '((1) (1 2 3) ()))
        '(((1)) ((1) (2) (3)) ())

        > (map-map (lambda (x) (* x x)) '((1) (1 2 3) ()))
        '((1) (1 4 9) ())


15. Да се напише функция, която прилага **map** рекурсивно върху елементите на
    списък.

    *Сигнатура:*

        (map-rec f L)

    *Примери:*

        > (map-rec (lambda (x) (* x 2)) '((1 (2 3 (4 5 6 (7) 8) 9 10 (11 12 (13 (14 15))) 16) 17 18) 19 20))
        '((2 (4 6 (8 10 12 (14) 16) 18 20 (22 24 (26 (28 30))) 32) 34 36) 38 40))


16. Да се напише функция, която прилага **filter** върху всеки елемент на списък
    от списъци, т.е. връща списък, съдържащ списъци с елементите на елементите на
    списъка от списъци, за които предикатът **p** е верен.

    *Сигнатура:*

        (filter-filter p L)

    *Примери:*

        > (filter-filter (lambda (x) #t) '((1 2 3) (4 5) (6) (7 8 9 10))
        '((1 2 3) (4 5) (6) (7 8 9 10))

        > (filter-filter (lambda (x) #f) '((1 2 3) (4 5) (6) (7 8 9 10))
        '(() () () ())

        > (filter-filter (lambda (x) (= (remainder x 2) 0)) '((1 2 3) (4 5) (6) (7 8 9 10))
        '((2) (4) (6) (8 10))

        > (filter-filter (lambda (x) (= (remainder x 3) 0)) '((1 2 3) (4 5) (6) (7 8 9 10))
        '((3) () (6) (9))


17. Да се напише функция, която прилага **filter** рекурсивно върху елементите на
    списък.

    *Сигнатура:*

        (filter-rec f L)

    *Примери:*

        > (filter-rec (lambda (x) (= (remainder x 2) 0)) '((1 (2 3 (4 5 6 (7) 8) 9 10 (11 12 (13 (14 15))) 16) 17 18) 19 20))
        '(((2 (4 6 () 8) 10 (12 ((14))) 16) 18) 20))


18. Да се реализира алгоритъмът
    **[quicksort](https://en.wikipedia.org/wiki/Quicksort)** върху списък **L**
    по подадена сравняваща функция **f**.

    *Сигнатура:*

        (quicksort L f)

    *Примери:*

        > (quicksort '(3 6 0 1 -9 7) <)
        '(-9 0 1 3 6 7)


19. Да се реализира алгоритъмът
    **[merge sort](https://en.wikipedia.org/wiki/Merge_sort)** върху списък **L**
    по подадена сравняваща функция **f**.

    *Сигнатура:*

        (mergesort L f)

    *Примери:*

        > (mergesort '(3 6 0 1 -9 7) <)
        '(-9 0 1 3 6 7)


20. Напишете функция, която по даден списък **L** връща списък с всички негови
    пермутации (редът, в който самите пермутации са подредени, няма значение).

    *Сигнатура:*

        (permute L)

    *Примери:*

        > (permute '(1 2 3))
        '((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))


21. Напишете функция, която по даден списък **L** връща списък с всички негови
    **n**-елементни подредици (т.е. съдържат **n** последователни елемента от
    **L**).

    *Сигнатура:*

        (subsequences-n n L)

    *Примери:*

        > (subsequences-n 2 '(1 2 3 4))
        '((1 2) (2 3) (3 4))


22. Напишете функция, която по даден списък **L** връща списък с всички негови
    **n**-елементни подсписъци (т.е. съдържат **n** елементa от **L** в същия
    ред).

    *Сигнатура:*

        (sublists-n n L)

    *Примери:*

        > (sublists-n 2 '(1 2 3 4))
        '((1 2) (1 3) (1 4) (2 3) (2 4) (3 4))


23. Напишете функция, която по даден списък **L** връща списък с всички негови
    **n**-елементни подмножества (т.е. съдържат елементи от **L** в какъвто и да
    е ред).

    *Сигнатура:*

        (subsets-n n L)

    *Примери:*

        > (subsets-n 2 '(1 2 3 4))
        '((1 2) (1 3) (1 4) (2 1) (2 3) (2 4) (3 1) (3 2) (3 4))


24. Напишете функция, която връща всички подредици на даден списък **L**.

    *Сигнатура:*

        (subsequences L)

    *Примери:*

        > (subsequences '(1 2 3 4))
        '(() (1) (2) (3) (4) (1 2) (2 3) (3 4) (1 2 3) (2 3 4) (1 2 3 4))


25. Напишете функция, която връща всички подсписъци на даден списък **L**
    (т.е. съдържат елементи от **L** в същия ред).

    *Сигнатура:*

        (sublists L)

    *Примери:*

        > (sublists '(1 2 3 4))
        '(() (1) (2) (3) (4) (1 2) (1 3) (1 4) (2 3) (2 4) (3 4) (1 2 3) (1 2 4) (2 3 4) (1 2 3 4))


26. Напишете функция, която връща всички подмножества на даден списък **L**
    (т.е. съдържат елементи от **L** в какъвто и да е ред).

    *Сигнатура:*

        (subsets L)

    *Примери:*

        > (subsets '(1 2 3 4))
        '(() (1) (2) (3) (4) (1 2) (1 3) (1 4) (2 1) (2 3) (2 4) (3 1) (3 2) (3 4) (1 2 3) (1 2 4) (1 3 2) (1 3 4) (1 4 2) (1 4 3) (2 1 3) (2 1 4) (2 3 1) (2 3 4) (2 4 1) (2 4 3) (3 1 2) (3 1 4) (3 2 1) (3 2 4) (3 4 1) (3 4 2) (4 1 2) (4 1 3) (4 2 1) (4 2 3) (4 3 1) (4 3 2) (1 2 3 4) (1 2 4 3) (1 3 2 4) (1 3 4 2) (1 4 2 3) (1 4 3 2) (2 1 3 4) (2 1 4 3) (2 3 1 4) (2 3 4 1) (2 4 1 3) (2 4 3 1) (3 1 2 4) (3 1 4 2) (3 2 1 4) (3 2 4 1) (3 4 1 2) (3 4 2 1) (4 1 2 3) (4 1 3 2) (4 2 1 3) (4 2 3 1) (4 3 1 2) (4 3 2 1))
